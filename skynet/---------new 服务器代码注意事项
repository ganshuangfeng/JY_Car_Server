

服务器和客户端：
	c2s:(客户端 to 服务器)
		*.客户端请求不要太频繁，现在有请求数量最大限制(每个客户端每5秒150个)，这个问题不大
		*.客户端传入的参数，一定要做严格检查，保证传入的参数是你允许的期望的值
		*.客户端请求函数中，是否加入操作锁，保证操作的原子性

	s2c:(服务器 to 客户端)
		*.每个服务端到客户端的请求(或给客户端的请求的返回)，单个消息的量不能太大(参考数值：100kb以内)
		*.服务器往客户端请求的消息量，频率不要太频繁，（参考数值：10条/s）
		*.

服务器和数据库：
	s2d:(服务器 to 数据库)
		*.向数据库写入，频率控制，如果频繁写入的东西，使用延迟写入模块。
		*.

	d2s:(数据库 to 服务器)
		*.加载数据库数据，一定不能全表载入所有人的数据，一定是使用内存管理模块，一条一条加入并写入内存。
		*.从数据库中查询数据的sql，where后面的条件字段，必须的加上索引，或者本身就是主键
		*.从数据库中查询数据的sql，复杂度不要太复杂，需要评估
		*.从数据库中查数据，不能从一直增长的数据表中查询统计数据(比如不能从日志表中查询统计)
		*.对相同的数据，禁止频繁从数据库中查询，只能查一次，并缓存在内存

服务器内部：
	*.跨节点之间的调用，频率不能太高，参考数值：10w/s
	*.节点内部的调用，应该是内存级别的调用，不用太做关心。
	*.高并发的处理操作，需要做单位时间处理上限的限制。（向全服在线人员发送消息时，一定要有单位时间最大发送数量的控制，不能瞬间执行）
	*.消耗资产注意:
		1.是否扣除资产
		2.是否判断资产是否足够
		3.
	*.获得资产注意：
		1.是否有超过逻辑数额和次数的限制(比如只能返一次的奖，是否未限制住，导致一直返奖)
		2.获得的数值是否正确(不能多获得)
		3.如果有是否领奖的状态控制(没领奖才能领)，判断没领奖之后，需要先设置领奖状态为领奖，再发奖。(避免奔溃导致钱加了，但是领奖状态还是未领奖)

	*.买礼包涉及的逻辑注意拉起支付后不支付的情况 或 拉起支付后先不支付,然后去做一些其他操作,再支付是否有bug
	*.是否有死循环的情况，导致CPU占用过高，或程序卡死 （ 看到while神经就要绷紧 ）
	*.注意程序是否能够被热更新
